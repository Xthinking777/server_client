#  高并发服务器框架开发笔记

## 一、项目目标

构建一个基于 Linux 的 C++ 网络通信框架，具备以下核心能力：

1. ✅ 解决 TCP 协议中的粘包问题
2. ✅ 自定义应用层协议并实现业务逻辑分发
3. ✅ 使用线程池异步处理任务，提升并发性能
4. ✅ 实现连接池与延迟回收机制，增强系统稳定性

---

## 二、核心技术点概览

| 技术点        | 原理说明                                            |
| ------------- | --------------------------------------------------- |
| epoll         | Linux 下高效的 I/O 多路复用机制，支持高并发事件监听 |
| 包头+包体协议 | 应用层自定义格式，解决 TCP 数据边界模糊问题         |
| 线程池        | 提前创建多个线程，共享任务队列，提高并发处理效率    |
| 连接池        | 缓存客户端连接对象，避免频繁创建销毁                |
| 延迟回收      | 利用智能指针控制资源释放时机，防止多线程访问异常    |

---

## 三、模块原理详解

---

### 1️⃣ 模块一：解决 TCP 粘包问题

#### 🔍 问题背景

TCP 是面向流的协议，数据以字节流形式传输，没有消息边界。因此会出现如下两种典型粘包情况：

- **多个小包被合并成一个大包接收**
- **一个大包被拆分成多个小包接收**

这会导致服务器无法正确解析出每个完整的业务数据单元。

#### 🛠️ 解决方案：包头+包体结构

我们通过在应用层定义统一的数据格式来标识每一个完整的消息单元：

```
[Header (固定长度)] + [Body (可变长度)]
```

- Header 中包含 Body 的长度信息
- 接收端先读取 Header，获取 Body 长度
- 再读取指定长度的 Body 数据

这样即使数据被粘在一起或被拆分，也可以准确提取出每条完整消息。

#### 📌 关键点

- 必须使用缓冲区保存未处理完的数据
- 必须循环读取直到收到完整数据包
- 必须确保 Header 和 Body 分别解析

---

### 2️⃣ 模块二：根据数据包执行不同业务逻辑

#### 📦 自定义应用层协议

为了区分不同的业务类型，我们在 Header 中加入 `msg_id` 字段，表示该数据包对应的业务类型。

例如：

- `msg_id = 1` 表示登录请求
- `msg_id = 2` 表示聊天消息
- `msg_id = 3` 表示登出通知

#### 🔄 业务逻辑分发机制

我们采用“注册-回调”方式，将每个 `msg_id` 对应到具体的业务处理函数中：

1. 在程序启动时注册所有支持的消息类型及其对应的处理函数
2. 收到完整数据包后，解析 `msg_id`
3. 查找注册表，调用对应处理函数
4. 处理完成后构造响应包返回给客户端

这种方式具有良好的扩展性，新增业务只需添加新 handler 并注册即可。

---

### 3️⃣ 模块三：线程池异步处理业务逻辑

#### ⚙️ 为什么需要线程池？

在网络服务器中，如果所有业务逻辑都在主线程同步执行，会阻塞主线程，影响整体吞吐量。为了解决这个问题，我们引入线程池机制。

#### 🧱 线程池的工作原理

- **初始化阶段**：预先创建若干个工作线程
- **任务提交**：将待处理的任务放入共享的任务队列中
- **任务调度**：空闲线程从队列中取出任务执行
- **线程管理**：线程池维护线程生命周期，避免频繁创建销毁

#### 🧩 线程池的优势

- 提升并发能力
- 减少线程创建销毁开销
- 控制最大并发数，防止资源耗尽
- 主线程不被阻塞，保持事件监听高效运行

---

### 4️⃣ 模块四：连接池与延迟回收机制

#### 🧵 什么是连接池？

连接池是一个缓存客户端连接对象的容器。当有新的客户端连接到来时，不是每次都 new Connection，而是从连接池中获取一个已有的对象进行复用。

#### 🧹 延迟回收的意义

网络服务器中经常出现这样的场景：

> 主线程认为某个连接已经关闭，准备删除其对象；但此时线程池中可能还有任务正在使用这个对象。

如果立即删除，就会导致 **野指针访问** 或 **内存越界** 错误。

延迟回收机制就是为了解决这个问题：

- 当主线程检测到连接断开，将其从连接池中移除
- 此时线程池任务仍持有该对象的引用（如 shared_ptr）
- 最后一个使用者释放资源时，才真正完成对象析构

#### 💡 延迟回收的实现关键

- 使用 `std::shared_ptr` 管理对象生命周期
- 所有对连接对象的访问都必须是共享引用
- 避免直接 delete，依赖引用计数自动释放

---

## 四、系统流程总览

```
[客户端发送请求]
         ↓
[epoll 监听到可读事件]
         ↓
[从连接池获取 Connection]
         ↓
[判断是否为完整包]
         ↓
[YES → 提交线程池处理]
         ↓
[线程池执行业务逻辑]
         ↓
[调用 sendResponse 发送响应]
         ↓
[客户端接收响应]
```

---

## 五、开发收获总结

| 学习内容       | 掌握技能                                 |
| -------------- | ---------------------------------------- |
| TCP 粘包问题   | 能够识别并解决常见的网络通信问题         |
| 自定义协议设计 | 具备构建应用层协议的能力                 |
| 事件驱动架构   | 理解基于事件的消息分发机制               |
| 多线程编程     | 掌握线程池、条件变量、任务队列等高级用法 |
| 资源管理       | 熟悉智能指针、连接池、延迟回收等技巧     |
| 系统稳定性优化 | 能识别并消除潜在的崩溃风险点             |

---

## 六、后续优化方向

| 功能              | 描述                           |
| ----------------- | ------------------------------ |
| 日志系统          | 记录运行日志，便于调试与监控   |
| 性能统计          | 统计 QPS、平均响应时间等指标   |
| HTTPS / WebSocket | 扩展支持加密通信和实时双向通信 |
| 数据库连接池      | 支持持久化操作                 |
| 定时器机制        | 支持心跳包、超时检测等功能     |

---

## 七、参考资料推荐

| 资料名称                  | 简介                                        |
| ------------------------- | ------------------------------------------- |
| 《Linux高性能服务器编程》 | 深入讲解网络编程、I/O模型、多线程等核心技术 |
| 《C++ Primer》            | 熟练掌握现代 C++ 编程特性                   |
| 《UNP：Unix网络编程》     | 经典网络编程书籍，适合进阶                  |
| GitHub 开源项目           | 如 muduo、libevent，参考工业级实现          |
